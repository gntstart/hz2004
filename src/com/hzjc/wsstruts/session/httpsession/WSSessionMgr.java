/* Generated by Together */

package com.hzjc.wsstruts.session.httpsession;

import java.util.ArrayList;
import java.util.Enumeration;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Set;

import javax.xml.rpc.server.ServiceLifecycle;
import org.apache.axis.components.logger.LogFactory;
import org.apache.axis.encoding.Base64;
import org.apache.commons.logging.Log;

import com.hzjc.hz2004.base.login.AuthToken;
import com.hzjc.hz2004.service.Hz2004ServiceHelper;

/**
 *  Adapter SimpleSessionHander
 * see @org.apache.axis.handlers.SimpleSessionHandler
 *
 * 调用方式:WSSessionMgr.getInstance.*
 * <p>Title: Hz2004</p>
 * <p>Description: 常住人口管理系统Hz2004版</p>
 * <p>Copyright: Copyright (c) 2004</p>
 * <p>Company: 浙江金铖华元新技术有限公司</p>
 * @author kgb_hz@126.com,kgb@primetech.com.cn
 * @version 1.0
 * @History 2005-01-06 1、增加内存中的Session管理同数据库中的用户会话同步
 *                     2、清除回收内存中的Session时，同时清除数据库中的用户会话
 */
public class WSSessionMgr {
  protected static Log _log = LogFactory.getLog(WSSessionMgr.class.getName());

  private static WSSessionMgr sessionMgr = null;
  //private static Hashtable activeSessions = new Hashtable();
  private static Map activeSessions = new HashMap();

  //存储用户名和SID的关系，以便登陆排斥
  private static Map activeSessionsUser = new HashMap();

  /**
   *
   */
  protected WSSessionMgr() {

  }

  /**
   *
   * @return
   */
  public synchronized static WSSessionMgr getInstance() {
    if (sessionMgr == null) {
      sessionMgr = new WSSessionMgr();
      //读取并设置回收Session内存周期
      //读取并设置Session默认的Session超时时间
    }
    return sessionMgr;
  }

  /**
   * Set the reaper periodicity in SECONDS
   *
   * Convenience method for testing.
   *
   * !!! TODO: Should be able to set this via options on the Handler
   * or perhaps the engine.
   */
  private void setReapPeriodicity(long reapTime) {
    reapPeriodicity = reapTime;
  }

  /**
   * Set the default session timeout in SECONDS
   *
   * Again, for testing.
   */
  private void setDefaultSessionTimeout(int defaultSessionTimeout) {
    this.defaultSessionTimeout = defaultSessionTimeout;
  }

  /**
   * 判断当前Session是否有效,是否处在活动期
   * @param sessionId
   * @return
   */
  private boolean isSessionValidate(String strSessionId) {
    if (strSessionId == null) {
      return false;
    }
    return activeSessions.containsKey(strSessionId);
  }

  //====================================================================
  // Reap timed-out sessions on the first request after this many
  // seconds.
  //设置回收Session周期
  //====================================================================
  private long reapPeriodicity = 60 * 60 * 1; //设置回收时间为1小时
  // By default, sessions time out after 1 minute of inactivity (60 sec)
  private int defaultSessionTimeout = 60 * 60 * 2; //默认设置会话时间为2个小时
  private long lastReapTime = 0;

  /**
   * 回收超时的Session,主要由于客户端没有注销异常退出的,因此必须清楚已经无效的会话
   * 故利用该方法进行处理
   */
  private void reapSessions() {
    // Should we reap timed out sessions?
    long curTime = System.currentTimeMillis();
    boolean reap = false;

    // Minimize synchronicity, just check in here, do reap later.
    synchronized (this) {
      if (curTime > lastReapTime + (reapPeriodicity * 1000)) {
        reap = true;
        lastReapTime = curTime;
      }
    }

    if (reap) {
      Set entries = activeSessions.entrySet();
      Set victims = new HashSet();
      Object key;
      Iterator i;
      for (i = entries.iterator(); i.hasNext(); ) {
        Map.Entry entry = (Map.Entry) i.next();
        key = entry.getKey();
        SimpleSession session = (SimpleSession) entry.getValue();
        if ( (curTime - session.getLastAccessTime()) >
            (session.getTimeout() * 1000)) {

          //============================================================
          // Don't modify the hashtable while we're iterating.
          //============================================================
          victims.add(key);
        }
      }

      //================================================================
      // Now go remove all the victims we found during the iteration.
      //================================================================
      for (i = victims.iterator(); i.hasNext(); ) {
        key = i.next();
        SimpleSession session = (SimpleSession) activeSessions.get(key);
        activeSessions.remove(key);

        //=============================================================
        //add by kgb 2004-01-06，同步删除数据库中的记录
        //=============================================================
        com.hzjc.hz2004.service.Hz2004ServiceHelper.getInstance().removeUserSessionInDb(String.valueOf(key));

        //=============================================================
        // For each victim, swing through the data looking for
        // ServiceLifecycle objects, and calling destroy() on them.
        // FIXME : This cleanup should probably happen on another
        //         thread, as it might take a little while.
        //============================================================
        Enumeration keys = session.getKeys();
        while (keys != null && keys.hasMoreElements()) {
          String keystr = (String) keys.nextElement();
          Object obj = session.get(keystr);
          if (obj != null && obj instanceof ServiceLifecycle) {
            ( (ServiceLifecycle) obj).destroy();
          }
        }
      }
    }

  }

  //////////////////////////////////////////////////////////////////////////
  // pulbic公共方法
  //////////////////////////////////////////////////////////////////////////
  /**
   * 判断用户会话是否在活动期,如果在则触发该Session
   * 供控制器在调用某一动作前验证用户的有效性
   * @param sessionId
   * @return
   */
  public boolean checkSession(String sessionId) {
    if (sessionId == null) {
      return false;
    }
    //回收无效的用户会话
    reapSessions();
    //判断Session是否有效
    boolean bActived = isSessionValidate(sessionId);
    if (bActived) {
      SimpleSession session = (SimpleSession) activeSessions.get(sessionId);
      session.touch();
    }
    return bActived;
  }

  /**
   * 将用户的SessionId进行Base64编码（28位）
   * @param strSessionId
   * @return
   */
  private String encrypSessionId(String strSessionId) {
	    String strRet = strSessionId;
	    strRet = Base64.encode(strSessionId.getBytes());
	    return strRet;
	  }

  /**
   * Generate a new session, register it, and return its ID.
   *
   * @return the new session's ID for later lookup.
   */
  /**
     public synchronized String getNewSession() {
    Long id = SessionUtils.generateSession();
    SimpleSession session = new SimpleSession();
    session.setTimeout(defaultSessionTimeout);
    //activeSessions.put(id, session);
    //edit kgb 2004-05-06
    //sessionid进行base64编码，或者其他加密算法
    String strSessionId = String.valueOf(id);
    strSessionId = encrypSessionId(strSessionId); //编码
    activeSessions.put(strSessionId, session);
    _log.info("登录用户ID=" + strSessionId);
    return strSessionId;
     }
   **/

  /**
   * 将AuthInfo用户的认证令牌添加到Session中
   * @param strAuthInfo -- 用户认证的AuthInfo信息
   * @param auth        -- 用户认证令牌类
   */
  public synchronized void addSessionByAuthToken(String strAuthInfo,AuthToken auth) {
    //创建Session
    SimpleSession session = new SimpleSession();
    session.setTimeout(defaultSessionTimeout);
    session.set(strAuthInfo, auth);

    //排斥
    if(activeSessionsUser.containsKey(auth.getYhdlm())){
      String oldid = (String)activeSessionsUser.get(auth.getYhdlm());
      Hz2004ServiceHelper.logoutUser(oldid);
    }

    //将Session添加放入HashMap
    activeSessions.put(strAuthInfo, session);
    //建立登陆名关系，便于排斥
    activeSessionsUser.put(auth.getYhdlm(),strAuthInfo);
  }

  /**
   * 用户登录后，将用户认证令牌添加到Session中，返回该用户的AuthInfo信息
   * @param auth -- 用户认证令牌类
   * @return     -- 返回用户认证的AuthInfo信息
   */
  public synchronized String addSessionByAuthToken(AuthToken auth) {
    SimpleSession session = new SimpleSession();
    session.setTimeout(defaultSessionTimeout);
    //===========================================================
    //edit kgb 2004-05-06
    //sessionid进行base64编码，或者其他加密算法
    //===========================================================
    //创建Session
    Long id = SessionUtils.generateSession();
    String strSessionId = String.valueOf(id);
    strSessionId = encrypSessionId(strSessionId); //编码
    session.set(strSessionId, auth);

    //排斥
    if(activeSessionsUser.containsKey(auth.getYhdlm())){
      String oldid = (String)activeSessionsUser.get(auth.getYhdlm());
      Hz2004ServiceHelper.logoutUser(oldid);
    }

    //添加到HashMap中
    activeSessions.put(strSessionId, session);
    //建立登陆名关系，便于排斥
    activeSessionsUser.put(auth.getYhdlm(),strSessionId);

    _log.info("用户会话的认证AuthInfoID=" + strSessionId);
    return strSessionId;
  }

  /**
   * 根据用户SessionID返回该用户对应的Session
   * @param sessionId -- 用户会话的SessionID
   * @return
   */
  public Session getSessionById(String strSessionId) {
    if (strSessionId == null) {
      return null;
    }
    return (Session) activeSessions.get(strSessionId);
  }

  /**
   * 查询返回所有活动用户Session列表
   * @return
   */
  public List getActiveUsers() {
    List lstUsrs = new ArrayList();
    //清除无效session
    reapSessions();
    for (Iterator iter = activeSessions.entrySet().iterator(); iter.hasNext(); ) {
      Map.Entry entry = (Map.Entry) iter.next();
      //if (isSessionValidate( (Long) entry.getKey())) {
      lstUsrs.add(entry.getValue());
      //}
    }
    return lstUsrs;
  }

  /**
   * 查询返回所有活动用户Session散列
   * @return
   */
  public Map getActiveSessions() {
    //清除无效session
    reapSessions();
    return activeSessions;
  }

  /**
   * 返回活动在线用户数
   * @return
   */
  public int getActiveUserCount() {
    return getActiveUsers().size();
  }

  /**
   * 清除、删除用户会话
   * @param sessionid -- 用户会话ID
   */
  public void removeSession(String sessionid) {
    if (isSessionValidate(sessionid)) {
      activeSessions.remove(sessionid);
      _log.info("注销用户ID=" + sessionid);
    }
  }

}
