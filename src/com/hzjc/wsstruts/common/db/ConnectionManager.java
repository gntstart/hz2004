/* Generated by Together */

package com.hzjc.wsstruts.common.db;

import java.io.*;
import java.sql.*;
import java.util.*;
import javax.naming.*;
import javax.sql.*;
import org.apache.commons.logging.*;

/**
 *
 * <p>Title: </p>
 * <p>Description: </p>
 * <p>Copyright: Copyright (c) 2003</p>
 * <p>Company: </p>
 * @Kansanku(kgb_hz@126.com)
 * @version 1.0
 */
public class ConnectionManager {

  protected static Log _log = LogFactory.getLog(ConnectionManager.class.getName());

  // True if the database support transactions.
  protected static boolean supportsTransactions = true;
  // True if the database requires large text fields to be streamed.
  protected static boolean streamLargeText = true;
  // True if the database supports the Statement.setMaxRows() method.
  protected static boolean supportsMaxRows = true;
  // True if the database supports the Statement.setFetchSize() method.
  protected static boolean supportsFetchSize = true;
  // True if the database supports correlated subqueries.
  protected static boolean supportsSubqueries = true;
  // True if the database supports scroll-insensitive results.
  protected static boolean supportsScrollResults = true;

//    private static DataSource dataSource=init();
  private static DataSource dataSource = null;

  /**
   *
   */
  private ConnectionManager() {

  }

  // Get DB Info
  public static synchronized void init() {
    _log.info("ConnManager::init() Initializing datasource...");
    //(1)search JNDI first
    //String dataSourceName = "oracle_jdbc_poola"; /**@todo get from config*/
    String dataSourceName = DbConfig.getInstance().getProperty(DbConfig.
        JDBC_TAG_DATASOURCE_JNDI);
    if (dataSourceName != null && dataSourceName.length() > 0) {
      try {
        Properties contextProperties = new Properties();
        /*
          for (int i=0; i<jndiPropertyKeys.length; i++) {
            String k = jndiPropertyKeys[i];
            String v = JiveGlobals.getJiveProperty(k);
            if (v != null) {
                contextProperties.setProperty(k,v);
            }
         }
         */
        Context context = null;
        if (contextProperties.size() > 0) {
          context = new InitialContext(contextProperties);
        }
        else {
          context = new InitialContext();
        }
        dataSource = (DataSource) context.lookup(dataSourceName);
        //return (DataSource)context.lookup(dataSourceName);
        return;
      }
      catch (Exception e) {
        _log.warn("WARNING: Could not lookup DataSource '" +
                  dataSourceName + "'! Error: " + e.getMessage());
      }
    }
    _log.warn("Try load connection pool ...");
    //dataSource = DefaultDataSource.getInstance();
    dataSource = new DefaultDataSource();
    //return DefaultDataSource.getInstance();
    /*
      Connection conn = null;
      try{
        conn = getConnection();
        setMetaData(conn);
      }catch(Exception e){
      }finally{
        try{conn.close();}catch(Exception ee){}
        conn = null;
        }
     */
  }

  public static Connection getConnection() {
    try {
      //Class.forName("org.gjt.mm.mysql.Driver");
      //Properties props = new java.util.Properties();
      //props.put("characterEncoding","GBK");
      //props.put("useUnicode", "true");
      //props.put("user", "root");
      //props.put("password", "root123");
      //return DriverManager.getConnection("jdbc:mysql://localhost:3306/cxweb", props);
      //System.out.println("ConnManager::getConnection() Called!");
      //Class.forName ("oracle.jdbc.driver.OracleDriver").newInstance ();
      //return DriverManager.getConnection("jdbc:oracle:thin:@218.108.37.115:1521:"+"yzttest","sitedb", "1234");
      if (dataSource == null) {
        init();
      }
      return dataSource.getConnection();
    }
    catch (Exception e) {
      _log.error(e.toString());
      return null;
    }
  }

  /**
   * Returns a Connection from the currently active connection provider that
   * is ready to participate in transactions (auto commit is set to false).
   */
  public static Connection getTransactionConnection() throws SQLException {
    Connection con = getConnection();
    if (supportsTransactions) {
      con.setAutoCommit(false);
    }
    return con;
  }

  public static synchronized void closeConnection(Connection conn) {
    try {
      conn.close();
      conn = null;
    }
    catch (Exception e) {
      _log.error("Close connection failed! " + e.getMessage());
    }
  }

  /**
   * Closes a Connection. However, it first rolls back the transaction or
   * commits it depending on the value of <code>abortTransaction</code>.
   */
  public static void closeTransactionConnection(Connection con,
                                                boolean abortTransaction) {
    // Rollback or commit the transaction
    if (supportsTransactions) {
      try {
        if (abortTransaction) {
          con.rollback();
        }
        else {
          con.commit();
        }
      }
      catch (Exception e) {
        _log.error("Close connection failed! " + e.getMessage());
      }
    }
    try {
      // Reset the connection to auto-commit mode.
      if (supportsTransactions) {
        con.setAutoCommit(true);
      }
    }
    catch (Exception e) {
      _log.error("Close connection failed! " + e.getMessage());
    }
    try {
      // Close the db connection.
      con.close();
    }
    catch (Exception e) {
      _log.error("Close connection failed! " + e.getMessage());
    }
  }

  /**
   * Creates a scroll insensitive Statement if the JDBC driver supports it, or a normal
   * Staement otherwise.
   *
   * @param con the database connection.
   * @return a Statement
   * @throws SQLException if an error occurs.
   */
  public static Statement createScrollableStatement(Connection con) throws
      SQLException {
    if (supportsScrollResults) {
      return con.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,
                                 ResultSet.CONCUR_READ_ONLY);
    }
    else {
      return con.createStatement();
    }
  }

  /**
   * Creates a scroll insensitive PreparedStatement if the JDBC driver supports it, or a normal
   * PreparedStaement otherwise.
   *
   * @param con the database connection.
   * @param sql the SQL to create the PreparedStatement with.
   * @return a PreparedStatement
   * @throws SQLException if an error occurs.
   */
  public static PreparedStatement createScrollablePreparedStatement(Connection
      con, String sql) throws SQLException {
    if (supportsScrollResults) {
      return con.prepareStatement(sql, ResultSet.TYPE_SCROLL_INSENSITIVE,
                                  ResultSet.CONCUR_READ_ONLY);
    }
    else {
      return con.prepareStatement(sql);
    }
  }

  /**
   * Scrolls forward in a result set to the specified row number. If the JDBC driver supports
   * the feature, the cursor will be moved directly. Otherwise, we scroll through results one by
   * one manually by calling <tt>rs.next()</tt>.
   *
   * @param rs the ResultSet object to scroll.
   * @param rowNumber the row number to scroll forward to.
   * @throws SQLException if an error occurs.
   */
  public static void scrollResultSet(ResultSet rs, int rowNumber) throws
      SQLException {
    // If the driver supports scrollable result sets, use that feature.
    if (supportsScrollResults) {
      if (rowNumber > 0) {
        rs.setFetchDirection(ResultSet.FETCH_FORWARD);
        rs.absolute(rowNumber);
      }
    }
    // Otherwise, manually scroll to the correct row.
    else {
      for (int i = 0; i < rowNumber; i++) {
        rs.next();
      }
    }
  }

  /**
   * Sets the max number of rows that should be returned from executing a
       * statement. The operation is automatically bypassed if System knows that the
   * the JDBC driver or database doesn't support it.
   *
   * @param stmt the Statement to set the max number of rows for.
   * @param maxRows the max number of rows to return.
   */
  public static void setMaxRows(Statement stmt, int maxRows) {
    if (supportsMaxRows) {
      try {
        stmt.setMaxRows(maxRows);
      }
      catch (Throwable t) {
        // Ignore. Exception may happen if the driver doesn't support
        // this operation and we didn't set meta-data correctly.
        // However, it is a good idea to update the meta-data so that
        // we don't have to incur the cost of catching an exception
        // each time.
        supportsMaxRows = false;
      }
    }
  }

  /**
   * Sets the number of rows that the JDBC driver should buffer at a time.
   * The operation is automatically bypassed if System knows that the
   * the JDBC driver or database doesn't support it.
   *
   * @param rs the ResultSet to set the fetch size for.
   * @param fetchSize the fetchSize.
   */
  public static void setFetchSize(ResultSet rs, int fetchSize) {
    if (supportsFetchSize) {
      try {
        rs.setFetchSize(fetchSize);
      }
      catch (Throwable t) {
        // Ignore. Exception may happen if the driver doesn't support
        // this operation and we didn't set meta-data correctly.
        // However, it is a good idea to update the meta-data so that
        // we don't have to incur the cost of catching an exception
        // each time.
        supportsFetchSize = false;
      }
    }
  }

  public static String getLargeTextField(ResultSet rs, int categoryIndex) throws
      SQLException {
    if (streamLargeText) {
      Reader bodyReader = null;
      String value = null;
      try {
        bodyReader = rs.getCharacterStream(categoryIndex);
        if (bodyReader == null) {
          return null;
        }
        char[] buf = new char[256];
        int len;
        StringWriter out = new StringWriter(256);
        while ( (len = bodyReader.read(buf)) >= 0) {
          out.write(buf, 0, len);
        }
        value = out.toString();
        out.close();
      }
      catch (Exception e) {
        e.printStackTrace();
        throw new SQLException("Failed to load text field");
      }
      finally {
        try {
          bodyReader.close();
        }
        catch (Exception e) {}
      }
      return value;
    }
    else {
      return rs.getString(categoryIndex);
    }
  }

  /**
   * Sets a large text category in a result set, automatically performing
   * streaming if the JDBC driver requires it. This is necessary because
   * different JDBC drivers have different capabilities and methods for
   * setting large text values.
   *
   * @param pstmt the PreparedStatement to set the text field in.
   * @param parameterIndex the index corresponding to the text field.
   * @param value the String to set.
   */
  public static void setLargeTextField(PreparedStatement pstmt,
                                       int parameterIndex, String value) throws
      SQLException {
    if (streamLargeText) {
      Reader bodyReader = null;
      try {
        bodyReader = new StringReader(value);
        pstmt.setCharacterStream(parameterIndex, bodyReader, value.length());
      }
      catch (Exception e) {
        e.printStackTrace();
        throw new SQLException("Failed to set text field.");
      }
      // Leave bodyReader open so that the db can read from it. It *should*
      // be garbage collected after it's done without needing to call close.
    }
    else {
      pstmt.setString(parameterIndex, value);
    }
  }

  public static String getBlobField(ResultSet rs, int parameterIndex) {
    Blob blob = null;
    String text = null;

    try {
      blob = rs.getBlob(parameterIndex);
      text = dumpBlob(blob);
    }
    catch (Exception ex) {
      _log.warn("getBlob():null" + ex);
    }
    return text;
  }

  private static String dumpBlob(Blob blob) throws Exception {
    // Get binary output stream to retrieve blob data
    InputStream instream = null;
    String text = null;
    instream = blob.getBinaryStream();

    int textLength = (int) blob.length();
    // Create temporary buffer for read
    byte[] buffer = new byte[textLength];

    // length of bytes read
    instream.read(buffer);
    text = new String(buffer);

    // Close input stream
    instream.close();
    return text;
  }

  /**
   * Uses a connection from the database to set meta data information about
   * what different JDBC drivers and databases support.
   */
  private static void setMetaData(Connection con) throws SQLException {
    DatabaseMetaData metaData = con.getMetaData();
    // Supports transactions?
    supportsTransactions = metaData.supportsTransactions();
    // Supports subqueries?
    supportsSubqueries = metaData.supportsCorrelatedSubqueries();
    // Supports scroll insensitive result sets?
    supportsScrollResults = metaData.supportsResultSetType(ResultSet.
        TYPE_SCROLL_INSENSITIVE);

    // Set defaults for other meta properties
    streamLargeText = false;
    supportsMaxRows = true;
    supportsFetchSize = true;

    // Get the database name so that we can perform meta data settings.
    String dbName = metaData.getDatabaseProductName().toLowerCase();
    String driverName = metaData.getDriverName().toLowerCase();

    // Oracle properties.
    if (dbName.indexOf("oracle") != -1) {
//            databaseType = DatabaseType.ORACLE;
      streamLargeText = true;
      // The i-net AUGURO JDBC driver
      if (driverName.indexOf("auguro") != -1) {
        streamLargeText = false;
        supportsFetchSize = true;
        supportsMaxRows = false;
      }
    }
    // Postgres properties
    else if (dbName.indexOf("postgres") != -1) {
//            databaseType = DatabaseType.POSTGRES;
      // Postgres blows, so disable scrolling result sets.
      supportsScrollResults = false;
      supportsFetchSize = false;
    }
    // Interbase properties
    else if (dbName.indexOf("interbase") != -1) {
      supportsFetchSize = false;
      supportsMaxRows = false;
    }
    // SQLServer, JDBC driver i-net UNA properties
    else if (dbName.indexOf("sql server") != -1 &&
             driverName.indexOf("una") != -1) {
      supportsFetchSize = true;
      supportsMaxRows = false;
    }
    // MySQL properties
    else if (dbName.indexOf("mysql") != -1) {
//            databaseType = DatabaseType.MYSQL;
    }
  }

}
